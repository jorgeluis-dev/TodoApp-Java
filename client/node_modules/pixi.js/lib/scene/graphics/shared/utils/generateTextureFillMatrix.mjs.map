{"version":3,"file":"generateTextureFillMatrix.mjs","sources":["../../../../../src/scene/graphics/shared/utils/generateTextureFillMatrix.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        textureMatrix.translate(-bounds.x, -bounds.y);\n        textureMatrix.scale(1 / bounds.width, 1 / bounds.height);\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n\n        const sourceStyle = style.texture.source.style;\n\n        // Ensure texture repeats properly\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n            sourceStyle.update();\n        }\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n"],"names":[],"mappings":";;;;AAUA,MAAM,iBAAA,GAAoB,IAAI,MAAO,EAAA,CAAA;AAMrC,MAAM,QAAA,GAAW,IAAI,SAAU,EAAA,CAAA;AAoBxB,SAAS,qBAAsB,CAAA,GAAA,EAAa,KAAkB,EAAA,KAAA,EAAuB,MAC5F,EAAA;AAEI,EAAM,MAAA,aAAA,GAAgB,KAAM,CAAA,MAAA,GACtB,GAAI,CAAA,QAAA,CAAS,KAAM,CAAA,MAAM,CAAE,CAAA,MAAA,EAC3B,GAAA,GAAA,CAAI,QAAS,EAAA,CAAA;AAEnB,EAAI,IAAA,KAAA,CAAM,iBAAiB,OAC3B,EAAA;AAEI,IAAM,MAAA,MAAA,GAAS,KAAM,CAAA,SAAA,CAAU,QAAQ,CAAA,CAAA;AAEvC,IAAA,aAAA,CAAc,UAAU,CAAC,MAAA,CAAO,CAAG,EAAA,CAAC,OAAO,CAAC,CAAA,CAAA;AAC5C,IAAA,aAAA,CAAc,MAAM,CAAI,GAAA,MAAA,CAAO,KAAO,EAAA,CAAA,GAAI,OAAO,MAAM,CAAA,CAAA;AAAA,GAG3D,MAAA;AAEI,IAAc,aAAA,CAAA,SAAA,CAAU,MAAM,OAAQ,CAAA,KAAA,CAAM,GAAG,KAAM,CAAA,OAAA,CAAQ,MAAM,CAAC,CAAA,CAAA;AACpE,IAAc,aAAA,CAAA,KAAA,CAAM,CAAI,GAAA,KAAA,CAAM,OAAQ,CAAA,MAAA,CAAO,OAAO,CAAI,GAAA,KAAA,CAAM,OAAQ,CAAA,MAAA,CAAO,MAAM,CAAA,CAAA;AAEnF,IAAM,MAAA,WAAA,GAAc,KAAM,CAAA,OAAA,CAAQ,MAAO,CAAA,KAAA,CAAA;AAGzC,IAAI,IAAA,WAAA,CAAY,gBAAgB,eAChC,EAAA;AACI,MAAA,WAAA,CAAY,WAAc,GAAA,QAAA,CAAA;AAC1B,MAAA,WAAA,CAAY,MAAO,EAAA,CAAA;AAAA,KACvB;AAAA,GACJ;AAGA,EAAA,IAAI,MACJ,EAAA;AACI,IAAA,aAAA,CAAc,OAAO,iBAAkB,CAAA,QAAA,CAAS,MAAM,CAAA,CAAE,QAAQ,CAAA,CAAA;AAAA,GACpE;AAEA,EAAO,OAAA,aAAA,CAAA;AACX;;;;"}